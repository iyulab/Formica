# 자주 묻는 질문 (FAQ)

## 일반 질문

### Q1: Formology와 기존 방법론의 가장 큰 차이는?

**A**: **시작점**이 다릅니다.

```
기존: 추상적 개념(Entity, Domain Model)부터
Formology: 구체적 문서(의뢰서, 보고서)부터

결과:
기존: 현업 이해 어려움, 개발자만 논의
Formology: 현업 직접 참여, 즉시 검증
```

---

### Q2: 문서가 너무 많이 나오면 어떻게 하나요?

**A**: 괜찮습니다! 실제 업무가 그만큼 복잡한 것입니다.

**대응 방법**:
1. **그룹핑**: 비슷한 문서끼리 묶기
2. **우선순위**: MVP는 핵심 5~7개만
3. **단계별 개발**: 1차/2차/3차로 나눔
4. **템플릿 활용**: 패턴 재사용

```
50개 문서 도출 시:
→ 그룹핑: 10개 그룹
→ MVP: 핵심 7개만
→ 2차: 15개 추가
→ 3차: 나머지
```

---

### Q3: 개발자가 Entity 모델링 하고 싶어해요

**A**: 내부적으로는 자유, 하지만 현업에게는 문서 용어만 사용

**규칙**:
```
현업 소통: 문서 이름 (품질검사의뢰서)
코드 내부: Entity 자유 (QcRequest)

단, 현업에게 Entity 얘기는 절대 금지!
```

**설득 방법**:
- "현업 이해가 최우선입니다"
- "코드 안에서는 자유롭게 하세요"
- "하지만 화면/메뉴는 문서 용어로"

---

### Q4: 전자결재 시스템이랑 뭐가 다른가요?

**A**: **범위**가 다릅니다.

| 항목 | 전자결재 | Formology |
|------|---------|---------|
| 대상 | 결재 문서만 | 모든 업무 문서 |
| 범위 | 승인 워크플로우 | 업무 전체 |
| 예시 | 휴가신청서, 구매요청서 | 작업일지, 체크리스트 포함 |

**관계**:
- Formology가 더 넓은 개념
- 전자결재는 Formology의 일부

---

## 기술 질문

### Q5: 모든 문서를 DB에 저장하나요?

**A**: 하이브리드 권장

**구조화된 데이터** → DB
```
문서 메타정보: DB
양식 필드 값: DB
관계 정보: DB
```

**비구조화된 데이터** → 파일
```
긴 텍스트: 파일 or TEXT 컬럼
이미지: 파일 (경로만 DB)
첨부파일: 파일 (경로만 DB)
```

---

### Q6: 성능 문제는 없나요?

**A**: 일반적으로 문제없습니다. 오히려 유리할 수 있습니다.

**Formology의 성능 이점**:
```
1. 명확한 Scope
   - 문서 단위 조회
   - 인덱스 설계 용이

2. 적절한 정규화
   - 자연스러운 1NF~3NF
   - 중복 최소화

3. 예측 가능한 쿼리
   - 문서 조회 패턴 명확
   - 캐싱 전략 수립 용이
```

**주의사항**:
- 대용량 첨부파일은 별도 스토리지
- 이력 테이블은 파티셔닝 고려
- 검색 기능은 전문검색 엔진 활용

---

### Q7: 마이크로서비스에도 맞나요?

**A**: 완벽히 맞습니다!

**문서 = Bounded Context**
```
품질검사 서비스:
├─ 검사의뢰서
├─ 검사기록지
└─ 검사보고서

생산 서비스:
├─ 작업지시서
├─ 작업일지
└─ 생산실적표

자재 서비스:
├─ 자재요청서
├─ 입고확인서
└─ 재고현황표
```

**서비스 간 통신**:
- 문서 ID로 참조
- 이벤트: "검사보고서 발행됨"
- API: `/qc-service/inspection-reports/{id}`

---

### Q8: 문서 버전 관리는 어떻게?

**A**: 패턴별로 다르게 접근

**패턴 1: 이력 테이블**
```sql
CREATE TABLE qc_requests_history (
  id PK,
  request_id FK,
  version INT,
  changed_at TIMESTAMP,
  changed_by VARCHAR,
  snapshot JSON
);
```

**패턴 2: Supersedes 관계**
```sql
CREATE TABLE work_standards (
  id PK,
  version VARCHAR,
  supersedes_id FK,  -- 이전 버전
  effective_date DATE
);
```

**패턴 3: 이벤트 소싱**
```sql
CREATE TABLE document_events (
  id PK,
  document_id VARCHAR,
  event_type VARCHAR,
  event_data JSON,
  occurred_at TIMESTAMP
);
```

---

## 적용 질문

### Q9: 어떤 프로젝트에 적합한가요?

**✅ 매우 적합**:
- 제조 MES/QMS/CMMS
- 병원 EMR/OCS
- 물류 WMS/TMS
- 사무 전자결재/문서관리
- 연구 LIMS

**⚠️ 부분 적합**:
- SNS (글/댓글은 문서로 볼 수 있음)
- 이커머스 (주문서, 배송지 등)
- 교육 (강의자료, 과제 등)

**❌ 부적합**:
- 순수 알고리즘 (추천, 검색)
- 실시간 제어 시스템
- 게임 (일부 기능 제외)
- 스트리밍 서비스

---

### Q10: 기존 시스템에 적용 가능한가요?

**A**: 가능하지만, 단계적 접근 필요

**단계 1: 분석**
```
기존 시스템 분석:
- 어떤 화면들이 있나?
- 어떤 데이터를 다루나?
→ 문서로 역변환 가능한지 확인
```

**단계 2: 매핑**
```
기존 → 문서 매핑:
"주문 관리" → "주문서", "배송지시서"
"재고 관리" → "입고확인서", "재고현황표"
```

**단계 3: 점진적 적용**
```
신규 기능: Formology 방식
기존 기능: 유지 (또는 점진적 전환)
```

---

### Q11: 비개발자도 시스템 설계에 참여할 수 있나요?

**A**: 바로 그것이 Formology의 핵심입니다!

**현업의 역할**:
```
워크숍:
✓ 문서 목록 도출 (주도)
✓ 양식 스케치 (주도)
✓ 업무 흐름 정의 (주도)
✓ 검증 (주도)

개발:
✓ 화면 확인 (검증)
✓ 기능 테스트 (검증)
✓ 피드백 제공 (검증)
```

**필요한 것**:
- IT 지식: ❌ 불필요
- 업무 이해: ✅ 필수
- 문서 이름 짓기: ✅ 가능
- 양식 그리기: ✅ 가능

---

## 비교 질문

### Q12: DDD(Domain-Driven Design)와의 차이는?

**공통점**:
- 도메인 중심 사고
- 유비쿼터스 언어 (현장 언어)
- Bounded Context 개념

**차이점**:

| 측면 | DDD | Formology |
|------|-----|---------|
| 시작 | Entity, Aggregate | 문서, 양식 |
| 추상화 | 즉시 | 점진적 |
| 현업 참여 | 간접 (인터뷰) | 직접 (워크숍) |
| 학습곡선 | 가파름 | 완만함 |
| 복잡도 | 높음 | 낮음 |

**결합 가능**:
- Formology로 시작 (구체적)
- 패턴 발견 후 DDD 적용 (추상화)

---

### Q13: 온톨로지와의 관계는?

**A**: Formology는 **경량 온톨로지**를 자연스럽게 도출

**차이**:

| 측면 | 전통 온톨로지 | Formology |
|------|-------------|---------|
| 시작점 | 최상위 개념부터 | 구체적 문서부터 |
| 도구 | OWL, Protégé | 일반 도구 |
| 현업 노출 | 온톨로지 용어 | 문서 용어 |
| 위치 | 시스템 표면 | 시스템 내부 |

**상세**: [온톨로지 비교 문서](../02-methodology/ontology-comparison.md)

---

## 구현 질문

### Q14: 추천 기술 스택은?

**A**: Formology는 기술 중립적이지만, 추천은 있습니다.

**Backend**:
```
Node.js + TypeScript
Python + FastAPI
Java + Spring Boot
C# + .NET

→ 문서 기반 REST API 구현 용이
```

**Database**:
```
PostgreSQL (추천)
MySQL
SQL Server

+ MongoDB (비정형 데이터)

→ 문서 = 테이블 매핑 명확
```

**Frontend**:
```
React + TypeScript
Vue.js
Angular

+ Form 라이브러리 (React Hook Form 등)

→ 양식 기반 UI 개발 용이
```

---

### Q15: API 설계는 어떻게?

**A**: 문서 이름 그대로 엔드포인트로

```
문서: 품질검사의뢰서

API:
POST   /qc-requests          # 의뢰서 작성
GET    /qc-requests/{id}     # 의뢰서 조회
PUT    /qc-requests/{id}     # 의뢰서 수정
DELETE /qc-requests/{id}     # 의뢰서 삭제
POST   /qc-requests/{id}/submit  # 의뢰서 제출
```

**상세**: [API 설계 문서](../05-realization/api-design.md)

---

## 프로세스 질문

### Q16: 워크숍 참석자가 의견 충돌하면?

**A**: 둘 다 기록하고, 차이를 명확히

**대처법**:
```
1. 둘 다 유효한 의견으로 기록
2. 차이가 발생하는 상황 명확히
   "A부서는 이렇게, B부서는 이렇게"
3. 시스템에서 둘 다 지원 검토
4. 불가능하면 우선순위 협의
```

**피해야 할 것**:
- 진행자가 판단
- 한쪽 의견 무시
- 완벽한 합의 강요

---

### Q17: 워크숍 후 문서가 계속 바뀌면?

**A**: 자연스러운 현상입니다. 진화를 허용하세요.

**대응**:
```
1. 변경 이력 관리
   - 언제, 누가, 왜 변경

2. 영향도 분석
   - 다른 문서에 영향?
   - 시스템 수정 필요?

3. 버전 관리
   - 문서 목록 v1.0 → v1.1

4. 정기 리뷰
   - 분기별 문서 목록 검토
```

---

## 성과 질문

### Q18: 실제 효과는?

**A**: 실제 프로젝트 결과

**정량적**:

| 항목 | 전통 방식 | Formology | 개선 |
|------|----------|---------|------|
| 요구사항 정의 | 3주 | 2일 | 90%↓ |
| 현업 이해도 | 40% | 95% | 137%↑ |
| 요구사항 변경 | 주 3회 | 주 0.3회 | 90%↓ |
| 데이터 모델 정확도 | 70% | 95% | 36%↑ |

**정성적**:
- 현업: "우리 하던 거 그대로!"
- 개발: "소통이 원활해요"
- 관리자: "일정 예측 가능해요"

**사례**: [제조 MES 사례](../06-case-studies/manufacturing-mes.md)

---

## 더 궁금한 점이 있다면?

- **질문하기**: [GitHub Discussions](https://github.com/your-repo/formology/discussions)
- **버그 리포트**: [GitHub Issues](https://github.com/your-repo/formology/issues)
- **문서 탐색**: [문서 인덱스](../index.md)

---

**"질문은 이해의 시작입니다"**
